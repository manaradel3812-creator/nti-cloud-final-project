name: Platform Deploy Pipeline

on:
  workflow_dispatch:
    inputs:
      env:
        description: 'Environment'
        required: true
        default: 'nonprod'
        type: choice
        options:
          - nonprod
          - prod

env:
  AWS_REGION: us-east-1
  HELM_NAMESPACE_INGRESS: ingress-nginx
  HELM_NAMESPACE_ARGOCD: argocd
  HELM_NAMESPACE_ES: external-secrets
  HELM_NAMESPACE_NEXUS: nexus
  HELM_NAMESPACE_SONAR: sonarqube

jobs:
  deploy-platform:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: false 

      - name: Download Terraform outputs
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: infrapipeline.yaml 
          name: terraform-outputs
          path: .
          search_artifacts: true

      - name: Set Terraform outputs as environment variables
        run: |
          FILE_PATH="tf-outputs.json"
          if [ ! -f "$FILE_PATH" ]; then echo "::error::tf-outputs.json missing!"; exit 1; fi
          CLUSTER=$(jq -r '.eks_cluster_name.value' $FILE_PATH)
          VPC=$(jq -r '.vpc_id.value' $FILE_PATH)
          LBC_ROLE=$(jq -r '.lbc_iam_role_arn.value // empty' $FILE_PATH)
          echo "CLUSTER_NAME=$CLUSTER" >> $GITHUB_ENV
          echo "VPC_ID=$VPC" >> $GITHUB_ENV
          echo "LBC_IAM_ROLE_ARN=$LBC_ROLE" >> $GITHUB_ENV

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up kubectl & Helm
        uses: azure/setup-kubectl@v4
      
      - uses: azure/setup-helm@v4

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      # --- ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬Ø§Ù‡Ø²ÙŠØ© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ù‚Ø¨Ù„ Ù†Ø´Ø± Ø£ÙŠ Ø®Ø¯Ù…Ø© ØªØ­ØªØ§Ø¬ PV ---
      - name: Verify Storage Readiness
        run: |
          echo "Checking for StorageClass efs-sc..."
          if kubectl get sc efs-sc; then
            echo "StorageClass efs-sc found. Proceeding..."
          else
            echo "Error: StorageClass efs-sc not found! Ensure Terraform Step 1 is complete."
            exit 1
          fi

          echo "Checking EFS CSI Driver status..."
          kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-efs-csi-driver

      - name: Clean up broken webhooks (Safe)
        run: |
          echo "Cleaning up any old webhooks to prevent conflicts..."
          kubectl delete mutatingwebhookconfiguration elbv2.k8s.aws-mutate --ignore-not-found
          kubectl delete validatingwebhookconfiguration elbv2.k8s.aws-validate --ignore-not-found

      - name: Create AWS LBC ServiceAccount
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: aws-load-balancer-controller
            namespace: kube-system
            annotations:
              eks.amazonaws.com/role-arn: ${{ env.LBC_IAM_ROLE_ARN }}
          EOF

      - name: Deploy AWS Load Balancer Controller
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=${{ env.CLUSTER_NAME }} \
            --set region=${{ env.AWS_REGION }} \
            --set vpcId=${{ env.VPC_ID }} \
            --set serviceAccount.create=false \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set resources.requests.cpu=256m \
            --set resources.requests.memory=512Mi \
            --set resources.limits.cpu=256m \
            --set resources.limits.memory=512Mi

      - name: Wait for LBC Controller
        run: |
          echo "Waiting for pods to be ready..."
          kubectl rollout status deployment/aws-load-balancer-controller -n kube-system --timeout=300s

      - name: Deploy NGINX Ingress (Auto-NLB)
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            -n ${{ env.HELM_NAMESPACE_INGRESS }} \
            --create-namespace \
            --set controller.service.type=LoadBalancer \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="external" \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-nlb-target-type"="ip" \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-scheme"="internet-facing"

      - name: Deploy ArgoCD
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          helm upgrade --install argocd argo/argo-cd -n ${{ env.HELM_NAMESPACE_ARGOCD }} --create-namespace --set server.service.type=ClusterIP

      # --- Ù†Ø´Ø± Nexus Ù…Ø¹ EFS PV ---
      - name: Deploy Nexus Repository
        run: |
          helm repo add sonatype https://sonatype.github.io/helm3-charts/
          helm repo update
          helm upgrade --install nexus sonatype/nexus-repository-manager \
            -n ${{ env.HELM_NAMESPACE_NEXUS }} \
            --create-namespace \
            -f k8s-configs/nexus.yaml

      # --- Ù†Ø´Ø± SonarQube Ù…Ø¹ EFS PV ---
      - name: Deploy SonarQube
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update
          helm upgrade --install sonarqube bitnami/sonarqube \
            -n ${{ env.HELM_NAMESPACE_SONAR }} \
            --create-namespace \
            -f k8s-configs/sonar.yaml \
            --timeout 10m

      - name: Apply Unified Platform Ingress
        run: |
          echo "Applying Ingress from helmchart path..."
          kubectl apply -f helmchart/ingress.yaml

      - name: ðŸš€ Final Deployment Summary
        run: |
          echo "===================================================="
          echo "âœ… DEPLOYMENT FINISHED SUCCESSFULLY!"
          echo "===================================================="
          echo "ðŸ”— Your LoadBalancer DNS:"
          kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
          echo -e "\n"
          echo "ðŸ” ArgoCD Initial Password:"
          kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
          echo -e "\n"
          echo "ðŸ› ï¸  Nexus Namespace: ${{ env.HELM_NAMESPACE_NEXUS }}"
          echo "ðŸ›¡ï¸  SonarQube Namespace: ${{ env.HELM_NAMESPACE_SONAR }}"
          echo "===================================================="
