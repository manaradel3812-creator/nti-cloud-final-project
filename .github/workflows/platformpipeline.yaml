name: Platform Deploy Pipeline

on:
  workflow_dispatch:
    inputs:
      env:
        description: 'Environment'
        required: true
        default: 'nonprod'
        type: choice
        options:
          - nonprod
          - prod

env:
  AWS_REGION: us-east-1
  HELM_NAMESPACE_INGRESS: ingress-nginx
  HELM_NAMESPACE_ARGOCD: argocd
  HELM_NAMESPACE_ES: external-secrets
  HELM_NAMESPACE_VAULT: vault
  HELM_NAMESPACE_NEXUS: nexus
  HELM_NAMESPACE_SONAR: sonarqube

jobs:
  deploy-platform:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: false 
          clean: true
          fetch-depth: 0

      - name: üîç Debug - Verify Helm Chart
        run: |
          echo "Listing helmchart folder contents..."
          ls -R helmchart

      - name: Download Terraform outputs
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: infrapipeline.yaml 
          name: terraform-outputs
          path: .
          search_artifacts: true

      - name: Set Terraform outputs as environment variables
        run: |
          FILE_PATH="tf-outputs.json"
          if [ ! -f "$FILE_PATH" ]; then
            echo "::error::tf-outputs.json missing!"
            exit 1
          fi
          CLUSTER=$(jq -r '.eks_cluster_name.value' $FILE_PATH)
          VPC=$(jq -r '.vpc_id.value' $FILE_PATH)
          LBC_ROLE=$(jq -r '.lbc_iam_role_arn.value // empty' $FILE_PATH)
          echo "CLUSTER_NAME=$CLUSTER" >> $GITHUB_ENV
          echo "VPC_ID=$VPC" >> $GITHUB_ENV
          echo "LBC_IAM_ROLE_ARN=$LBC_ROLE" >> $GITHUB_ENV

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
      
      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      - name: Verify Storage Readiness
        run: |
          echo "Checking for StorageClass efs-sc..."
          if kubectl get sc efs-sc; then
            echo "StorageClass efs-sc found. Proceeding..."
          else
            echo "Error: StorageClass efs-sc not found! Ensure Terraform Step 1 is complete."
            exit 1
          fi

          echo "Checking EFS CSI Driver status..."
          kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-efs-csi-driver

      - name: Clean up broken webhooks (Safe)
        run: |
          kubectl delete mutatingwebhookconfiguration elbv2.k8s.aws-mutate --ignore-not-found
          kubectl delete validatingwebhookconfiguration elbv2.k8s.aws-validate --ignore-not-found

      - name: Create AWS LBC ServiceAccount
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: aws-load-balancer-controller
            namespace: kube-system
            annotations:
              eks.amazonaws.com/role-arn: ${{ env.LBC_IAM_ROLE_ARN }}
          EOF

      - name: Deploy AWS Load Balancer Controller
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=${{ env.CLUSTER_NAME }} \
            --set region=${{ env.AWS_REGION }} \
            --set vpcId=${{ env.VPC_ID }} \
            --set serviceAccount.create=false \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set resources.requests.cpu=256m \
            --set resources.requests.memory=512Mi \
            --set resources.limits.cpu=256m \
            --set resources.limits.memory=512Mi

      - name: Wait for LBC Controller
        run: |
          kubectl rollout status deployment/aws-load-balancer-controller -n kube-system --timeout=300s

      - name: Deploy NGINX Ingress (NodePort)
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            -n ${{ env.HELM_NAMESPACE_INGRESS }} \
            --create-namespace \
            --set controller.service.type=NodePort \
            --wait=false \
            --atomic

      - name: Deploy ArgoCD
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          helm upgrade --install argocd argo/argo-cd \
            -n ${{ env.HELM_NAMESPACE_ARGOCD }} \
            --create-namespace \
            -f k8s-configs/argocd-values.yaml \
            --set server.service.type=ClusterIP

      - name: Deploy Vault
        run: |
          helm repo add hashicorp https://helm.releases.hashicorp.com
          helm repo update
          helm upgrade --install vault hashicorp/vault \
            -n ${{ env.HELM_NAMESPACE_VAULT }} \
            --create-namespace \
            --set server.dev.enabled=true \
            --set server.dev.devRootToken=root

      - name: Wait for Vault to be ready
        run: |
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=vault -n ${{ env.HELM_NAMESPACE_VAULT }} --timeout=300s

      - name: Configure Vault - Enable Kubernetes Auth
        run: |
          VAULT_POD=$(kubectl get pod -n ${{ env.HELM_NAMESPACE_VAULT }} -l app.kubernetes.io/name=vault -o jsonpath="{.items[0].metadata.name}")
          
          # Enable Kubernetes auth method
          kubectl exec -n ${{ env.HELM_NAMESPACE_VAULT }} $VAULT_POD -- vault auth enable kubernetes || true
          
          # Configure Kubernetes auth
          kubectl exec -n ${{ env.HELM_NAMESPACE_VAULT }} $VAULT_POD -- /bin/sh -c "
          vault write auth/kubernetes/config \
            kubernetes_host='https://\$KUBERNETES_PORT_443_TCP_ADDR:443' \
            kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
            token_reviewer_jwt=@/var/run/secrets/kubernetes.io/serviceaccount/token
          "

      - name: Create Vault Policy for ESO
        run: |
          VAULT_POD=$(kubectl get pod -n ${{ env.HELM_NAMESPACE_VAULT }} -l app.kubernetes.io/name=vault -o jsonpath="{.items[0].metadata.name}")
          
          kubectl exec -n ${{ env.HELM_NAMESPACE_VAULT }} $VAULT_POD -- /bin/sh -c 'vault policy write myapp-policy - <<EOF
          path "secret/data/myapp/*" {
            capabilities = ["read", "list"]
          }
          
          path "secret/metadata/myapp/*" {
            capabilities = ["list", "read"]
          }
          EOF'

      - name: Create Vault Role for ESO
        run: |
          VAULT_POD=$(kubectl get pod -n ${{ env.HELM_NAMESPACE_VAULT }} -l app.kubernetes.io/name=vault -o jsonpath="{.items[0].metadata.name}")
          
          kubectl exec -n ${{ env.HELM_NAMESPACE_VAULT }} $VAULT_POD -- vault write auth/kubernetes/role/myapp-role \
            bound_service_account_names=external-secrets-sa \
            bound_service_account_namespaces=default,external-secrets \
            policies=myapp-policy \
            ttl=24h

      - name: Store Sample Secrets in Vault
        run: |
          VAULT_POD=$(kubectl get pod -n ${{ env.HELM_NAMESPACE_VAULT }} -l app.kubernetes.io/name=vault -o jsonpath="{.items[0].metadata.name}")
          
          # Store sample database credentials
          kubectl exec -n ${{ env.HELM_NAMESPACE_VAULT }} $VAULT_POD -- vault kv put secret/myapp/db \
            username=dbuser \
            password=SecureP@ssw0rd123
          
          # Store sample API keys
          kubectl exec -n ${{ env.HELM_NAMESPACE_VAULT }} $VAULT_POD -- vault kv put secret/myapp/api \
            api_key=sk-1234567890abcdef \
            api_secret=secret-abcdefghijklmnop

      - name: Deploy External Secrets Operator
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
          helm upgrade --install external-secrets external-secrets/external-secrets \
            -n ${{ env.HELM_NAMESPACE_ES }} \
            --create-namespace \
            -f k8s-configs/eso-values.yaml \
            --wait

      - name: Wait for ESO to be ready
        run: |
          kubectl wait --for=condition=available deployment/external-secrets -n ${{ env.HELM_NAMESPACE_ES }} --timeout=300s
          kubectl wait --for=condition=available deployment/external-secrets-webhook -n ${{ env.HELM_NAMESPACE_ES }} --timeout=300s

      - name: Create ESO Service Account
        run: |
          kubectl apply -f k8s-configs/vault-serviceaccount.yaml

      - name: Create Vault SecretStore
        run: |
          kubectl apply -f k8s-configs/vault-secret-store.yaml

      - name: Create Sample ExternalSecret
        run: |
          kubectl apply -f k8s-configs/external-secret-example.yaml

      - name: Verify ESO Integration
        run: |
          echo "Waiting for ExternalSecret to sync..."
          sleep 30
          
          echo "Checking ExternalSecret status:"
          kubectl get externalsecret myapp-db-secret -o yaml
          
          echo ""
          echo "Checking if Kubernetes Secret was created:"
          if kubectl get secret myapp-db-credentials; then
            echo "‚úÖ Secret successfully created by ESO!"
            echo ""
            echo "Secret contents (base64 decoded):"
            echo "Username: $(kubectl get secret myapp-db-credentials -o jsonpath='{.data.username}' | base64 -d)"
            echo "Password: $(kubectl get secret myapp-db-credentials -o jsonpath='{.data.password}' | base64 -d)"
          else
            echo "‚ö†Ô∏è Secret not found. Check ESO logs:"
            kubectl logs -n external-secrets -l app.kubernetes.io/name=external-secrets --tail=50
          fi

      - name: Deploy Nexus Repository
        run: |
          helm repo add sonatype https://sonatype.github.io/helm3-charts/
          helm repo update
          helm upgrade --install nexus sonatype/nexus-repository-manager \
            -n ${{ env.HELM_NAMESPACE_NEXUS }} \
            --create-namespace \
            -f k8s-configs/nexus-values.yaml

      - name: Deploy SonarQube
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update

          if kubectl get secret -n ${{ env.HELM_NAMESPACE_SONAR }} sonarqube > /dev/null 2>&1; then
            SONARQUBE_PASSWORD=$(kubectl get secret -n ${{ env.HELM_NAMESPACE_SONAR }} sonarqube -o jsonpath="{.data.sonarqube-password}" | base64 --decode)
          else
            SONARQUBE_PASSWORD=MyStrongPassword123
          fi

          helm upgrade --install sonarqube bitnami/sonarqube \
            -n ${{ env.HELM_NAMESPACE_SONAR }} \
            --create-namespace \
            -f k8s-configs/sonar-values.yaml \
            --set sonarqubePassword=$SONARQUBE_PASSWORD \
            --timeout 10m

      - name: Apply Unified Platform Ingress
        run: |
          kubectl apply -f helmchart/templates/ingress.yaml

      - name: üöÄ Final Deployment Summary
        run: |
          echo "===================================================="
          echo "‚úÖ DEPLOYMENT FINISHED SUCCESSFULLY!"
          echo "===================================================="
          echo "üîó Your LoadBalancer DNS:"
          kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
          echo -e "\n"
          echo "üîê ArgoCD Initial Password:"
          kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
          echo -e "\n"
          echo "üîê Vault Root Token: root"
          echo "üîê Vault URL: http://vault.vault.svc.cluster.local:8200"
          echo ""
          echo "üîë External Secrets Operator Status:"
          kubectl get pods -n ${{ env.HELM_NAMESPACE_ES }}
          echo ""
          echo "üì¶ Sample Secrets in Vault:"
          echo "  - secret/myapp/db (username, password)"
          echo "  - secret/myapp/api (api_key, api_secret)"
          echo ""
          echo "üõ†Ô∏è  Nexus Namespace: ${{ env.HELM_NAMESPACE_NEXUS }}"
          echo "üõ°Ô∏è  SonarQube Namespace: ${{ env.HELM_NAMESPACE_SONAR }}"
          echo "====================================================" 
          
      - name: Re-Upload Terraform outputs for CI
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: tf-outputs.json
