name: CD Pipeline with ArgoCD

on:
  workflow_dispatch:
    inputs:
      deploy_mode:
        description: 'Deployment Mode'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - manual
      image_tag:
        description: 'Image Tag (optional - leave empty to use latest from CI)'
        required: false
        type: string
      cluster_name:
        description: 'EKS Cluster Name (optional - leave empty to use from CI)'
        required: false
        type: string
        default: ''

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      # 1Ô∏è‚É£ Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Download latest CI artifact
      - name: Download latest CI outputs
        id: download_artifact
        continue-on-error: true
        uses: dawidd6/action-download-artifact@v3
        with:
          name: terraform-outputs
          path: ./ci-outputs
          workflow_conclusion: success
          search_artifacts: true
          if_no_artifact_found: warn

      # 3Ô∏è‚É£ Parse outputs (with fallbacks)
      - name: Parse deployment config
        id: parse_outputs
        env:
          MANUAL_IMAGE_TAG: ${{ github.event.inputs.image_tag }}
          MANUAL_CLUSTER: ${{ github.event.inputs.cluster_name }}
        run: |
          # ŸÖÿ≠ÿßŸàŸÑÿ© ŸÇÿ±ÿßÿ°ÿ© ŸÖŸÜ artifact ÿ£ŸàŸÑÿßŸã
          if [ -f "./ci-outputs/tf-outputs.json" ]; then
            echo "‚úÖ Found CI artifact"
            CLUSTER_NAME=$(jq -r '.eks_cluster_name.value' ./ci-outputs/tf-outputs.json)
            AWS_REGION=$(jq -r '.aws_region.value // "us-east-1"' ./ci-outputs/tf-outputs.json)
            ECR_REPOSITORY=$(jq -r '.manar_app_ecr_url.value' ./ci-outputs/tf-outputs.json)
            ARTIFACT_IMAGE_TAG=$(jq -r '.image_tag.value' ./ci-outputs/tf-outputs.json)
          else
            echo "‚ö†Ô∏è No CI artifact found, using defaults/manual inputs"
            CLUSTER_NAME="${MANUAL_CLUSTER:-manar-eks-cluster}"
            AWS_REGION="us-east-1"
            ECR_REPOSITORY="${{ secrets.ECR_REPOSITORY }}"
            ARTIFACT_IMAGE_TAG=""
          fi
          
          # ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ manual input ŸÑŸà ŸÖŸàÿ¨ŸàÿØ
          if [ -n "$MANUAL_IMAGE_TAG" ]; then
            IMAGE_TAG="$MANUAL_IMAGE_TAG"
          elif [ -n "$ARTIFACT_IMAGE_TAG" ]; then
            IMAGE_TAG="$ARTIFACT_IMAGE_TAG"
          else
            # fallback ŸÑÿ¢ÿÆÿ± commit
            IMAGE_TAG=$(echo $GITHUB_SHA | cut -c1-7)
          fi
          
          if [ -n "$MANUAL_CLUSTER" ]; then
            CLUSTER_NAME="$MANUAL_CLUSTER"
          fi
          
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "AWS_REGION=$AWS_REGION" >> $GITHUB_ENV
          echo "ECR_REPOSITORY=$ECR_REPOSITORY" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          
          echo "‚úÖ Deployment config:"
          echo "  Cluster: $CLUSTER_NAME"
          echo "  Region: $AWS_REGION"
          echo "  Image: $ECR_REPOSITORY:$IMAGE_TAG"

      # 4Ô∏è‚É£ Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 5Ô∏è‚É£ Login to AWS ECR
      - name: Login to AWS ECR
        uses: aws-actions/amazon-ecr-login@v2

      # 6Ô∏è‚É£ Scan image with Trivy
      - name: Trivy vulnerability scan
        continue-on-error: true
        env:
          IMAGE_REF: ${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
        run: |
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
            --severity CRITICAL,HIGH \
            --exit-code 1 \
            --no-progress \
            "$IMAGE_REF" || echo "‚ö†Ô∏è Vulnerabilities found but continuing..."

      # 7Ô∏è‚É£ Manual Approval
      - name: Manual Approval Gate
        if: ${{ github.event.inputs.deploy_mode == 'manual' }}
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: manaradel3812-creator
          minimum-approvals: 1
          issue-title: "üöÄ Deploy ${{ env.IMAGE_TAG }} to Production"

      # 8Ô∏è‚É£ Checkout GitOps repository
      - name: Checkout GitOps repository
        env:
          GITOPS_TOKEN: ${{ secrets.GITOPS_TOKEN }}
        run: |
          git clone "https://${GITOPS_TOKEN}@github.com/manaradel3812-creator/nti-cloud-final-project.git" gitops-repo

      # 9Ô∏è‚É£ Update Helm values.yaml
      - name: Update Helm values.yaml
        env:
          NEW_IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          cd gitops-repo
          
          # ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ŸÖŸÑŸÅ values.yaml
          VALUES_FILE=""
          if [ -f "charts/hello-app/values.yaml" ]; then
            VALUES_FILE="charts/hello-app/values.yaml"
          elif [ -f "helmchart/values.yaml" ]; then
            VALUES_FILE="helmchart/values.yaml"
          else
            echo "‚ùå values.yaml not found!"
            find . -name "values.yaml"
            exit 1
          fi
          
          echo "üìù Updating $VALUES_FILE"
          sed -i "s|tag:.*|tag: \"${NEW_IMAGE_TAG}\"|g" "$VALUES_FILE"
          
          echo "‚úÖ Updated values:"
          grep -A2 "image:" "$VALUES_FILE"
          
          git config --global user.email "action@github.com"
          git config --global user.name "GitHub Action"
          git add "$VALUES_FILE"
          git commit -m "üöÄ Deploy image ${NEW_IMAGE_TAG} [skip ci]" || echo "No changes"
          git push origin main

      # üîü Setup kubectl
      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      # 1Ô∏è‚É£1Ô∏è‚É£ Update kubeconfig
      - name: Update kubeconfig
        env:
          REGION: ${{ env.AWS_REGION }}
          CLUSTER: ${{ env.CLUSTER_NAME }}
        run: |
          aws eks update-kubeconfig --region "$REGION" --name "$CLUSTER"

      # 1Ô∏è‚É£2Ô∏è‚É£ Verify ArgoCD
      - name: Check ArgoCD installation
        run: |
          if ! kubectl get namespace argocd &>/dev/null; then
            echo "‚ö†Ô∏è Installing ArgoCD..."
            kubectl create namespace argocd
            kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
            echo "‚è≥ Waiting for ArgoCD..."
            kubectl wait --for=condition=Ready pods --all -n argocd --timeout=300s
          else
            echo "‚úÖ ArgoCD already installed"
          fi

      # 1Ô∏è‚É£3Ô∏è‚É£ Apply ArgoCD Application (if exists)
      - name: Apply ArgoCD Application
        continue-on-error: true
        run: |
          cd gitops-repo
          if [ -f "k8s-configs/argocd-app.yaml" ]; then
            kubectl apply -f k8s-configs/argocd-app.yaml
            echo "‚úÖ ArgoCD Application deployed"
          else
            echo "‚ö†Ô∏è argocd-app.yaml not found, skipping ArgoCD setup"
            echo "üí° You can deploy manually using Helm"
          fi

      # 1Ô∏è‚É£4Ô∏è‚É£ Verify
      - name: Verify deployment
        run: |
          echo "‚è≥ Waiting 30s for sync..."
          sleep 30
          
          echo "üìä Cluster status:"
          kubectl get pods -n default || true
          kubectl get svc -n default || true
          
          echo ""
          echo "üéØ Target image: ${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}"
