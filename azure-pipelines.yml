trigger: none
pr: none

parameters:
  - name: env
    displayName: Environment
    type: string
    default: nonprod
    values: [nonprod, prod]
  - name: destroy
    displayName: Destroy Infra
    type: boolean
    default: false

variables:
  AWS_REGION: us-east-1
  INFRA_CONNECTION: manar    # Ø³Ù†Ø¨Ù‚ÙŠ Ø¹Ù„ÙŠÙ‡ Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ ÙÙ‚Ø· Ù„Ø£Ù† Terraform ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹Ù‡ Ø¬ÙŠØ¯Ø§Ù‹
  TF_DIR: terraform
  TF_VAR_FILE: '${{ parameters.env }}.tfvars'
  CLUSTER_NAME: '${{ parameters.env }}-eks-cluster'
  HELM_NAMESPACE: kube-system
  SERVICE_ACCOUNT: aws-load-balancer-controller
  KUBECONFIG_PATH: $(Pipeline.Workspace)/kubeconfig.yaml

stages:

#################################
# 1ï¸âƒ£ Stage: Terraform (ØªØ³ØªØ®Ø¯Ù… manar)
#################################
- stage: Infra
  displayName: "Infrastructure Deployment"
  jobs:
  - job: Terraform
    pool: { vmImage: ubuntu-latest }
    steps:
    - checkout: self
    - task: TerraformInstaller@1
      inputs: { terraformVersion: latest }
    - task: AWSShellScript@1
      displayName: "Run Terraform"
      inputs:
        awsCredentials: $(INFRA_CONNECTION)
        regionName: $(AWS_REGION)
        scriptType: inline
        inlineScript: |
          cd $(TF_DIR)
          terraform init -input=false
          if [ "${{ parameters.destroy }}" = "true" ]; then
            terraform destroy -auto-approve -var-file=$(TF_VAR_FILE)
          else
            terraform apply -auto-approve -var-file=$(TF_VAR_FILE)
          fi

#################################
# 2ï¸âƒ£ Stage: Platform (ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ù€ Secrets ÙŠØ¯ÙˆÙŠØ§Ù‹)
#################################
- stage: Platform
  displayName: "Kubernetes Platform Setup"
  dependsOn: Infra
  condition: and(succeeded(), eq('${{ parameters.destroy }}', false))
  jobs:
  - job: Helm
    pool: { vmImage: ubuntu-latest }
    steps:
    - checkout: self
    - task: KubectlInstaller@0
      inputs: { versionSpec: latest }
    - task: HelmInstaller@1
      inputs: { helmVersionToInstall: latest }

    - script: |
        set -euo pipefail
        
        echo "ğŸ› ï¸ Creating physical AWS credentials file..."
        mkdir -p ~/.aws
        
        # ÙƒØªØ§Ø¨Ø© Ù…Ù„Ù Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù…Ù† Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ© Ø§Ù„ØªÙŠ Ù‚Ù…ØªÙ Ø¨ØªØ¹Ø±ÙŠÙÙ‡Ø§ ÙÙŠ Ø§Ù„Ù€ UI
        cat <<EOF > ~/.aws/credentials
        [default]
        aws_access_key_id = $(MY_AWS_ACCESS_KEY)
        aws_secret_access_key = $(MY_AWS_SECRET_KEY)
        EOF

        cat <<EOF > ~/.aws/config
        [default]
        region = $(AWS_REGION)
        output = json
        EOF
        
        chmod 600 ~/.aws/credentials
        
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ù„Ù Ø§Ù„Ù€ Kubeconfig
        export KUBECONFIG=$(KUBECONFIG_PATH)
        echo "ğŸ” Updating Kubeconfig..."
        aws eks update-kubeconfig --name $(CLUSTER_NAME) --region $(AWS_REGION) --kubeconfig $KUBECONFIG

        echo "ğŸ” TESTING CONNECTION..."
        # Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø± Ø³ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† Ù„Ø£Ù† aws cli Ø³ÙŠØ¬Ø¯ Ù…Ù„Ù ~/.aws/credentials
        kubectl get nodes

        echo "ğŸ› ï¸ Deploying IRSA & Namespace..."
        kubectl create namespace $(HELM_NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -
        kubectl create serviceaccount $(SERVICE_ACCOUNT) -n $(HELM_NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -

        ROLE_ARN=$(aws iam get-role --role-name $(CLUSTER_NAME)-alb-controller-role --query Role.Arn --output text)
        kubectl annotate serviceaccount $(SERVICE_ACCOUNT) eks.amazonaws.com/role-arn=$ROLE_ARN -n $(HELM_NAMESPACE) --overwrite

        echo "ğŸ“¦ Installing AWS Load Balancer Controller..."
        helm repo add eks https://aws.github.io/eks-charts
        helm repo update
        
        VPC_ID=$(aws eks describe-cluster --name $(CLUSTER_NAME) --query "cluster.resourcesVpcConfig.vpcId" --output text)

        helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
          -n $(HELM_NAMESPACE) \
          --set clusterName=$(CLUSTER_NAME) \
          --set region=$(AWS_REGION) \
          --set vpcId=$VPC_ID \
          --set serviceAccount.create=false \
          --set serviceAccount.name=$(SERVICE_ACCOUNT)

        echo "ğŸš€ Installing ArgoCD & Cert-Manager..."
        helm repo add jetstack https://charts.jetstack.io
        helm repo add argo https://argoproj.github.io/argo-helm
        helm repo update
        
        helm upgrade --install cert-manager jetstack/cert-manager -n cert-manager --create-namespace --set installCRDs=true
        helm upgrade --install argocd argo/argo-cd -n argocd --create-namespace
      displayName: "Manual Credential Injection & Deploy"
      env:
        # Ø±Ø¨Ø· Ø§Ù„Ù€ Secrets Ø¨Ø§Ù„Ø¨ÙŠØ¦Ø© (Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹)
        MY_AWS_ACCESS_KEY: $(MY_AWS_ACCESS_KEY)
        MY_AWS_SECRET_KEY: $(MY_AWS_SECRET_KEY)